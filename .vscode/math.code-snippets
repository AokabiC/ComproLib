{
    // Place your compro workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "modint": {
        "prefix": "modint",
        "body": [
            "template<int mod>",
            "struct ModInt {",
            "    int x;",
            "",
            "    ModInt() : x(0) {}",
            "",
            "    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}",
            "",
            "    ModInt &operator+=(const ModInt &p) {",
            "        if((x += p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator-=(const ModInt &p) {",
            "        if((x += mod - p.x) >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator*=(const ModInt &p) {",
            "        x = (int)(1LL * x * p.x % mod);",
            "        return *this;",
            "    }",
            "",
            "    ModInt &operator/=(const ModInt &p) {",
            "        *this *= p.inverse();",
            "        return *this;",
            "    }",
            "",
            "    ModInt operator-() const { return ModInt(-x); }",
            "",
            "    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }",
            "",
            "    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }",
            "",
            "    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }",
            "",
            "    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }",
            "",
            "    bool operator==(const ModInt &p) const { return x == p.x; }",
            "",
            "    bool operator!=(const ModInt &p) const { return x != p.x; }",
            "",
            "    ModInt inverse() const {",
            "        int a = x, b = mod, u = 1, v = 0, t;",
            "        while(b > 0) {",
            "            t = a / b;",
            "            a -= t * b;",
            "            swap(a, b);",
            "            u -= t * v;",
            "            swap(u, v);",
            "        }",
            "        return ModInt(u);",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {",
            "        return os << p.x;",
            "    }",
            "",
            "    friend istream &operator>>(istream &is, ModInt<mod> &a) {",
            "        long long x;",
            "        is >> x;",
            "        a = ModInt<mod>(x);",
            "        return (is);",
            "    }",
            "};",
            "const int mod = 1e9 + 7;",
            "using modint = ModInt< mod >;"
        ],
        "description": "modint"
    }
}