{
    "UnionFind": {
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind {",
            "  private:",
            "    vector<int> data;",
            "  public:",
            "    UnionFind(int size) : data(size, -1) {}",
            "",
            "    bool merge(int x, int y) {",
            "        x = root(x);",
            "        y = root(y);",
            "        if(x == y) return false;",
            "        if(data[y] < data[x]) swap(x, y);",
            "        data[x] += data[y];",
            "        data[y] = x;",
            "        return true;",
            "    }",
            "",
            "    int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }",
            "",
            "    int size(int x) { return -data[root(x)]; }",
            "};"
        ],
        "description": "UnionFind"
      },
      "BinaryIndexedTree": {
        "prefix": "BinaryIndexedTree",
        "body": [
          "template< class T >",
          "struct BinaryIndexedTree {",
          "    vector< T > dat;",
          "",
          "    BinaryIndexedTree(int sz) {",
          "        dat.assign(++sz, 0);",
          "    }",
          "",
          "    T sum(int k){",
          "        T ret = 0;",
          "        for(++k; k > 0; k -= k & -k) ret += data[k];",
          "        return ret;",
          "    }",
          "",
          "    void add(int k, T x){",
          "        for(++k; k < data.size(); k += k & -k) data[k] += x;",
          "    }",
          "};"
        ],
        "description": "BinaryIndexedTree"
      },
      "Segtree": {
        "prefix": "Segtree",
        "body": [
            "/*",
            "!) 0-indexed",
            "!) [a, b)に対する演算",
            "!) merge, updateNodeを書く",
            "*/",
            "template<typename Monoid>",
            "struct Segtree{",
            "  private:",
            "    int n;",
            "    vector<Monoid> dat;",
            "    Monoid m0; // データの初期化値",
            "",
            "    Monoid merge(Monoid a, Monoid b){ return ; }    // 区間をマージする二項演算",
            "    void updateNode(int k, Monoid x){ dat[k] = ; }  // 区間を操作する二項演算",
            "",
            "  public:",
            "    Segtree(int sz, Monoid m0) : m0(m0){",
            "        n = 1;",
            "        while(n < sz) n *= 2;",
            "        dat.assign(2*n-1, m0);",
            "    }",
            "",
            "    void update(int k, Monoid x){",
            "        k += n-1;",
            "        updateNode(k, x);",
            "        while(k > 0) {",
            "            k = (k-1)/2;",
            "            dat[k] = merge(dat[k*2+1], dat[k*2+2]);",
            "        }",
            "    }",
            "    Monoid query(int a, int b){",
            "        Monoid L = m0, R = m0;",
            "        int A = a+n-1;",
            "        int B = b+n-1;",
            "        while(A < B) {",
            "            if((A&1) == 0) L = merge(L, dat[A++]);",
            "            if((B&1) == 0) R = merge(dat[--B], R);",
            "            A >>= 1;",
            "            B >>= 1;",
            "        }",
            "        return merge(L, R);",
            "    }",
            "    Monoid operator[](const int &k) const { return dat[k+n-1]; }",
            "};"
        ],
        "description": "Segtree"
      },
      "LazySegtree": {
        "prefix": "LazySegtree",
        "body": [
          "/*",
          "!) 0-indexed 遅延伝搬セグメント木",
          "!) [a, b)に対する演算",
          "!) M0, L0, merge, updateNode, propagateを書く",
          "*/",
          "template <typename Monoid>",
          "struct LazySegtree {",
          "    int n;",
          "    vector<Monoid> dat, lazy;",
          "",
          "    Monoid M0, L0 // データと遅延配列の初期化値 queryに合わせて選択する",
          "",
          "    LazySegtree(int sz, Monoid dat_init){",
          "        n = 1;",
          "        while (n < sz) n *= 2;",
          "        dat.assign(2*n-1, dat_init);",
          "        lazy.assign(2*n-1, L0);",
          "    }",
          "",
          "    Monoid merge(Monoid a, Monoid b) // 区間をマージする二項演算",
          "    void updateNode(int k, Monoid x) // 区間を操作する二項演算",
          "    void propagate(int k, int l, int r) // 遅延配列の伝搬のさせ方",
          "",
          "    void eval(int k, int l, int r) {",
          "        if(lazy[k] == L0) return;",
          "        propagate(k, l, r);",
          "        if(r-l > 1) {",
          "            updateNode(2*k+1, lazy[k]);",
          "            updateNode(2*k+2, lazy[k]);",
          "        }",
          "        lazy[k] = L0;",
          "    }",
          "",
          "    void update(int a, int b, Monoid x, int k, int l, int r) {",
          "        eval(k, l, r);",
          "        if (r <= a || b <= l) return;",
          "        if (a <= l && r <= b) {",
          "            updateNode(k, x);",
          "            eval(k, l, r);",
          "        }else{",
          "            update(a, b, x, k*2+1, l, (l+r)/2);",
          "            update(a, b, x, k*2+2, (l+r)/2, r);",
          "            dat[k] = merge(dat[2*k+1], dat[2*k+2]);",
          "        }",
          "    }",
          "",
          "    void update(int a, int b, Monoid x) {",
          "        update(a, b, x, 0, 0, n);",
          "    }",
          "",
          "    Monoid query(int a, int b, int k, int l, int r) {",
          "        eval(k, l, r);",
          "        if (r <= a || b <= l) return M0;",
          "        if (a <= l && r <= b) return dat[k];",
          "        Monoid L = query(a, b, k*2+1, l, (l+r)/2);",
          "        Monoid R = query(a, b, k*2+2, (l+r)/2, r);",
          "        return merge(L, R);",
          "    }",
          "",
          "    Monoid query(int a, int b){",
          "        return query(a, b, 0, 0, n);",
          "    }",
          "};",
          ""
        ],
        "description": "LazySegtree"
      }
}